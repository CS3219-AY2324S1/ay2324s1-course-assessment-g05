AWSTemplateFormatVersion: "2010-09-09"

Description: Peerprep AWS Cloudformation Stack v1.7

Parameters:
  ProjectName:
    Type: String
    Default: peerprep
    Description: "A friendly name that will be used for namespacing all cluster resources."
  EnvironmentName:
    Type: String
    Default: development
    Description: "Environment name that will be appended behind project name for namespacing all cluster resources."
    AllowedValues: [production, development, test]
  MinContainers:
    Type: Number
    Default: 1
    Description: "Minimum number of ECS tasks per ECS service"
  MaxContainers:
    Type: Number
    Default: 3
    Description: "Maximum number of ECS tasks per ECS service"
  AutoScalingTargetValue:
    Type: Number
    Default: 90
    Description: "Target CPU utilization (%) for ECS services auto scaling"
  QuestionServiceName:
    Type: String
    Default: question-service
    Description: "Container/DNS name for question service."
  MatchingServiceName:
    Type: String
    Default: matching-service
    Description: "Container/DNS name for matching service."
  AuthServiceName:
    Type: String
    Default: auth-service
    Description: "Container/DNS name for auth service."
  UserServiceName:
    Type: String
    Default: user-service
    Description: "Container/DNS name for user service."
  CollaborationServiceName:
    Type: String
    Default: collaboration-service
    Description: "Container/DNS name for collaboration service."
  HistoryServiceName:
    Type: String
    Default: history-service
    Description: "Container/DNS name for history service."
  EventBusName:
    Type: String
    Default: event-bus
    Description: "Container/DNS name for event-bus."

Conditions:
  UseNewRepo: !Not [!Equals [!Ref EnvironmentName, test]]

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Generic"
        Parameters:
          - ProjectName
          - EnvironmentName
      - Label:
          default: "ECS Container/DNS names"
        Parameters:
          - QuestionServiceName
          - MatchingServiceName
          - AuthServiceName
          - UserServiceName
          - CollaborationServiceName
          - HistoryServiceName
          - EventBusName
      - Label:
          default: "ECS Service Auto Scaling"
        Parameters:
          - MinContainersECS
          - MaxContainersECS
          - AutoScalingTargetValueECS

Mappings:
  SubnetConfig:
    VPC:
      CIDR: "10.0.0.0/16"
    Public:
      CIDR: "10.0.0.0/24"
    Private:
      CIDR: "10.0.100.0/24"

Resources:
  #===================================
  # VPC and networks
  #===================================
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      EnableDnsSupport: true
      EnableDnsHostnames: true
      CidrBlock: !FindInMap ["SubnetConfig", "VPC", "CIDR"]
      Tags:
        - Key: "Name"
          Value: !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "VPC"]]

  # Subnets
  PublicSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select
        - 0
        - Fn::GetAZs: !Ref "AWS::Region"
      VpcId: !Ref "VPC"
      CidrBlock: !FindInMap ["SubnetConfig", "Public", "CIDR"]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: "Name"
          Value:
            !Join [
              "-",
              [!Ref ProjectName, !Ref EnvironmentName, "PublicSubnet"],
            ]
  PrivateSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select
        - 0
        - Fn::GetAZs: !Ref "AWS::Region"
      VpcId: !Ref "VPC"
      CidrBlock: !FindInMap ["SubnetConfig", "Private", "CIDR"]
      Tags:
        - Key: "Name"
          Value:
            !Join [
              "-",
              [!Ref ProjectName, !Ref EnvironmentName, "PrivateSubnet"],
            ]

  # Route tables
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref "VPC"
      Tags:
        - Key: "Name"
          Value:
            !Join [
              "-",
              [!Ref ProjectName, !Ref EnvironmentName, "PublicRouteTable"],
            ]
  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: GatewayAttachment
    Properties:
      RouteTableId: !Ref "PublicRouteTable"
      DestinationCidrBlock: "0.0.0.0/0"
      GatewayId: !Ref "InternetGateway"
  PublicSubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet
      RouteTableId: !Ref PublicRouteTable
  PrivateRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref "VPC"
      Tags:
        - Key: "Name"
          Value:
            !Join [
              "-",
              [!Ref ProjectName, !Ref EnvironmentName, "PrivateRouteTable"],
            ]
  PrivateRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGateway
  PrivateRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      SubnetId: !Ref PrivateSubnet

  # Network connections
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: "Name"
          Value:
            !Join [
              "-",
              [!Ref ProjectName, !Ref EnvironmentName, "InternetGateway"],
            ]
  GatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref "VPC"
      InternetGatewayId: !Ref "InternetGateway"
  NatGatewayAttachment:
    Type: AWS::EC2::EIP
    DependsOn: GatewayAttachment
    Properties:
      Domain: vpc
  NatGateway:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NatGatewayAttachment.AllocationId
      SubnetId: !Ref PublicSubnet
      Tags:
        - Key: "Name"
          Value:
            !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "NatGateway"]]

  # Security group
  ContainerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName:
        !Join [
          "-",
          [!Ref ProjectName, !Ref EnvironmentName, "ContainerSecurityGroup"],
        ]
      GroupDescription: Access to the Fargate containers
      VpcId: !Ref "VPC"

  ContainerSecurityGroupSelfIngress80:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: !Join ["-", [!Ref EnvironmentName, "ingress-80"]]
      GroupId: !Ref ContainerSecurityGroup
      SourceSecurityGroupId: !Ref ContainerSecurityGroup
      IpProtocol: tcp
      FromPort: 80
      ToPort: 80

  ContainerSecurityGroupSelfIngress443:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: !Join ["-", [!Ref EnvironmentName, "ingress-443"]]
      GroupId: !Ref ContainerSecurityGroup
      SourceSecurityGroupId: !Ref ContainerSecurityGroup
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443

  ContainerSecurityGroupSelfIngress6379:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: !Join ["-", [!Ref EnvironmentName, "ingress-6379"]]
      GroupId: !Ref ContainerSecurityGroup
      SourceSecurityGroupId: !Ref ContainerSecurityGroup
      IpProtocol: tcp
      FromPort: 6379
      ToPort: 6379

  # VPC Endpoint
  VPCEndpointEcrDrk:
    Type: "AWS::EC2::VPCEndpoint"
    Properties:
      VpcEndpointType: "Interface"
      VpcId: !Ref VPC
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.ecr.dkr"
      PolicyDocument: '{"Version":"2008-10-17","Statement":[{"Effect":"Allow","Principal":"*","Action":"*","Resource":"*"}]}'
      SubnetIds:
        - !Ref PrivateSubnet
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !Ref ContainerSecurityGroup

  VPCEndpointEcrApi:
    Type: "AWS::EC2::VPCEndpoint"
    Properties:
      VpcEndpointType: "Interface"
      VpcId: !Ref VPC
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.ecr.api"
      PolicyDocument: '{"Version":"2008-10-17","Statement":[{"Effect":"Allow","Principal":"*","Action":"*","Resource":"*"}]}'
      SubnetIds:
        - !Ref PrivateSubnet
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !Ref ContainerSecurityGroup

  VPCEndpointS3:
    Type: "AWS::EC2::VPCEndpoint"
    Properties:
      VpcEndpointType: "Gateway"
      VpcId: !Ref VPC
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.s3"
      PolicyDocument: '{"Version":"2008-10-17","Statement":[{"Effect":"Allow","Principal":"*","Action":"*","Resource":"*"}]}'
      RouteTableIds:
        - !Ref PrivateRouteTable
      PrivateDnsEnabled: false

  VPCEndpointLogs:
    Type: "AWS::EC2::VPCEndpoint"
    Properties:
      VpcEndpointType: "Interface"
      VpcId: !Ref VPC
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.logs"
      PolicyDocument: '{"Version":"2008-10-17","Statement":[{"Effect":"Allow","Principal":"*","Action":"*","Resource":"*"}]}'
      SubnetIds:
        - !Ref PrivateSubnet
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !Ref ContainerSecurityGroup

  #===================================
  # IAM Roles
  #===================================
  AutoScalingRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName:
        !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "AutoScalingRole"]]
      Description: Authorize to manage auto scaling resources
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: "sts:AssumeRole"
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceAutoscaleRole"

  ECSRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "ECSRole"]]
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ecs.amazonaws.com]
            Action: ["sts:AssumeRole"]
      Path: /
      Policies:
        - PolicyName: ecs-service
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "ec2:AttachNetworkInterface"
                  - "ec2:CreateNetworkInterface"
                  - "ec2:CreateNetworkInterfacePermission"
                  - "ec2:DeleteNetworkInterface"
                  - "ec2:DeleteNetworkInterfacePermission"
                  - "ec2:Describe*"
                  - "ec2:DetachNetworkInterface"

                  - "elasticloadbalancing:DeregisterInstancesFromLoadBalancer"
                  - "elasticloadbalancing:DeregisterTargets"
                  - "elasticloadbalancing:Describe*"
                  - "elasticloadbalancing:RegisterInstancesWithLoadBalancer"
                  - "elasticloadbalancing:RegisterTargets"
                Resource: "*"

  ECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName:
        !Join [
          "-",
          [!Ref ProjectName, !Ref EnvironmentName, "ECSTaskExecutionRole"],
        ]
      Description: Authorize to execute tasks
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ecs-tasks.amazonaws.com]
            Action: ["sts:AssumeRole"]
      Path: /
      Policies:
        - PolicyName: AmazonECSTaskExecutionRolePolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  # Allow the ECS Tasks to download images from ECR
                  - "ecr:GetAuthorizationToken"
                  - "ecr:BatchCheckLayerAvailability"
                  - "ecr:GetDownloadUrlForLayer"
                  - "ecr:BatchGetImage"

                  # Allow the ECS tasks to upload logs to CloudWatch
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: "*"

  ECSTaskRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName:
        !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "ECSTaskRole"]]
      Description: Authorize to initialize task definition
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: "sts:AssumeRole"
      Path: /
      Policies:
        - PolicyName: AmazonECSTaskRolePolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "logs:CreateLogGroup"
                Resource: "*"

  #===================================
  # ECS Cluster
  #===================================
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName:
        !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "ECSCluster"]]
      ServiceConnectDefaults:
        Namespace: !GetAtt PrivateDNSNamespace.Arn

  #===================================
  # ECS Namespaces and ServiceDiscovery
  #===================================
  PrivateDNSNamespace:
    Type: "AWS::ServiceDiscovery::PrivateDnsNamespace"
    Properties:
      Vpc: !Ref VPC
      Name: !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "ns"]]

  ServiceDiscoveryQuestion:
    Type: "AWS::ServiceDiscovery::Service"
    Properties:
      DnsConfig:
        DnsRecords:
          - Type: SRV
            TTL: 60
        NamespaceId: !Ref PrivateDNSNamespace
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "sd-question"]]

  ServiceDiscoveryMatching:
    Type: "AWS::ServiceDiscovery::Service"
    Properties:
      DnsConfig:
        DnsRecords:
          - Type: SRV
            TTL: 60
        NamespaceId: !Ref PrivateDNSNamespace
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "sd-matching"]]

  ServiceDiscoveryUser:
    Type: "AWS::ServiceDiscovery::Service"
    Properties:
      DnsConfig:
        DnsRecords:
          - Type: SRV
            TTL: 60
        NamespaceId: !Ref PrivateDNSNamespace
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "sd-user"]]

  ServiceDiscoveryAuth:
    Type: "AWS::ServiceDiscovery::Service"
    Properties:
      DnsConfig:
        DnsRecords:
          - Type: SRV
            TTL: 60
        NamespaceId: !Ref PrivateDNSNamespace
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "sd-auth"]]

  ServiceDiscoveryCollaboration:
    Type: "AWS::ServiceDiscovery::Service"
    Properties:
      DnsConfig:
        DnsRecords:
          - Type: SRV
            TTL: 60
        NamespaceId: !Ref PrivateDNSNamespace
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name:
        !Join [
          "-",
          [!Ref ProjectName, !Ref EnvironmentName, "sd-collaboration"],
        ]

  ServiceDiscoveryEventBus:
    Type: "AWS::ServiceDiscovery::Service"
    Properties:
      DnsConfig:
        DnsRecords:
          - Type: SRV
            TTL: 60
        NamespaceId: !Ref PrivateDNSNamespace
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name:
        !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "sd-event-bus"]]

  ServiceDiscoveryHistory:
    Type: "AWS::ServiceDiscovery::Service"
    Properties:
      DnsConfig:
        DnsRecords:
          - Type: SRV
            TTL: 60
        NamespaceId: !Ref PrivateDNSNamespace
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "sd-history"]]

  #===================================
  # ECS Services
  #===================================
  ServiceQuestion:
    Type: AWS::ECS::Service
    DependsOn:
      - PrivateRoute
    Properties:
      ServiceName:
        !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "ServiceQuestion"]]
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref TaskDefinitionQuestion
      LaunchType: FARGATE
      DesiredCount: 1
      ServiceRegistries:
        - RegistryArn: !GetAtt ServiceDiscoveryQuestion.Arn
          Port: 80
      ServiceConnectConfiguration:
        Enabled: true
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-create-group: true
            awslogs-group:
              !Join [
                "-",
                [!Ref ProjectName, !Ref EnvironmentName, "sc-question"],
              ]
            awslogs-region: !Ref AWS::Region
            awslogs-stream-prefix: ecs
        Namespace: !GetAtt PrivateDNSNamespace.Arn
        Services:
          - ClientAliases:
              - DnsName: !Ref QuestionServiceName
                Port: 80
            DiscoveryName: !Ref QuestionServiceName
            PortName: !Join ["-", [!Ref QuestionServiceName, "80", "tcp"]]
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref PrivateSubnet
          SecurityGroups:
            - !Ref ContainerSecurityGroup

  ServiceMatching:
    Type: AWS::ECS::Service
    DependsOn:
      - PrivateRoute
    Properties:
      ServiceName:
        !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "ServiceMatching"]]
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref TaskDefinitionMatching
      LaunchType: FARGATE
      DesiredCount: 1
      ServiceRegistries:
        - RegistryArn: !GetAtt ServiceDiscoveryMatching.Arn
          Port: 80
      ServiceConnectConfiguration:
        Enabled: true
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-create-group: true
            awslogs-group:
              !Join [
                "-",
                [!Ref ProjectName, !Ref EnvironmentName, "sc-matching"],
              ]
            awslogs-region: !Ref AWS::Region
            awslogs-stream-prefix: ecs
        Namespace: !GetAtt PrivateDNSNamespace.Arn
        Services:
          - ClientAliases:
              - DnsName: !Ref MatchingServiceName
                Port: 80
            DiscoveryName: !Ref MatchingServiceName
            PortName: !Join ["-", [!Ref MatchingServiceName, "80", "tcp"]]
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref PrivateSubnet
          SecurityGroups:
            - !Ref ContainerSecurityGroup

  ServiceUser:
    Type: AWS::ECS::Service
    DependsOn:
      - PrivateRoute
    Properties:
      ServiceName:
        !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "ServiceUser"]]
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref TaskDefinitionUser
      LaunchType: FARGATE
      DesiredCount: 1
      ServiceRegistries:
        - RegistryArn: !GetAtt ServiceDiscoveryUser.Arn
          Port: 80
      ServiceConnectConfiguration:
        Enabled: true
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-create-group: true
            awslogs-group:
              !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "sc-user"]]
            awslogs-region: !Ref AWS::Region
            awslogs-stream-prefix: ecs
        Namespace: !GetAtt PrivateDNSNamespace.Arn
        Services:
          - ClientAliases:
              - DnsName: !Ref UserServiceName
                Port: 80
            DiscoveryName: !Ref UserServiceName
            PortName: !Join ["-", [!Ref UserServiceName, "80", "tcp"]]
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref PrivateSubnet
          SecurityGroups:
            - !Ref ContainerSecurityGroup

  ServiceAuth:
    Type: AWS::ECS::Service
    DependsOn:
      - PrivateRoute
    Properties:
      ServiceName:
        !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "ServiceAuth"]]
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref TaskDefinitionAuth
      LaunchType: FARGATE
      DesiredCount: 1
      ServiceRegistries:
        - RegistryArn: !GetAtt ServiceDiscoveryAuth.Arn
          Port: 80
      ServiceConnectConfiguration:
        Enabled: true
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-create-group: true
            awslogs-group:
              !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "sc-auth"]]
            awslogs-region: !Ref AWS::Region
            awslogs-stream-prefix: ecs
        Namespace: !GetAtt PrivateDNSNamespace.Arn
        Services:
          - ClientAliases:
              - DnsName: !Ref AuthServiceName
                Port: 80
            DiscoveryName: !Ref AuthServiceName
            PortName: !Join ["-", [!Ref AuthServiceName, "80", "tcp"]]
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref PrivateSubnet
          SecurityGroups:
            - !Ref ContainerSecurityGroup

  ServiceCollaboration:
    Type: AWS::ECS::Service
    DependsOn:
      - PrivateRoute
    Properties:
      ServiceName:
        !Join [
          "-",
          [!Ref ProjectName, !Ref EnvironmentName, "ServiceCollaboration"],
        ]
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref TaskDefinitionCollaboration
      LaunchType: FARGATE
      DesiredCount: 1
      ServiceRegistries:
        - RegistryArn: !GetAtt ServiceDiscoveryCollaboration.Arn
          Port: 80
      ServiceConnectConfiguration:
        Enabled: true
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-create-group: true
            awslogs-group:
              !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "sc-collab"]]
            awslogs-region: !Ref AWS::Region
            awslogs-stream-prefix: ecs
        Namespace: !GetAtt PrivateDNSNamespace.Arn
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref PrivateSubnet
          SecurityGroups:
            - !Ref ContainerSecurityGroup

  ServiceEventBus:
    Type: AWS::ECS::Service
    DependsOn:
      - PrivateRoute
    Properties:
      ServiceName:
        !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "ServiceEventBus"]]
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref TaskDefinitionEventBus
      LaunchType: FARGATE
      DesiredCount: 1
      ServiceConnectConfiguration:
        Enabled: true
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-create-group: true
            awslogs-group:
              !Join [
                "-",
                [!Ref ProjectName, !Ref EnvironmentName, "sc-event-bus"],
              ]
            awslogs-region: !Ref AWS::Region
            awslogs-stream-prefix: ecs
        Namespace: !GetAtt PrivateDNSNamespace.Arn
        Services:
          - ClientAliases:
              - DnsName: !Ref EventBusName
                Port: 6379
            DiscoveryName: !Ref EventBusName
            PortName: !Join ["-", [!Ref EventBusName, "6379", "tcp"]]
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref PrivateSubnet
          SecurityGroups:
            - !Ref ContainerSecurityGroup

  ServiceHistory:
    Type: AWS::ECS::Service
    DependsOn:
      - PrivateRoute
    Properties:
      ServiceName:
        !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "ServiceHistory"]]
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref TaskDefinitionHistory
      LaunchType: FARGATE
      DesiredCount: 1
      ServiceRegistries:
        - RegistryArn: !GetAtt ServiceDiscoveryHistory.Arn
          Port: 80
      ServiceConnectConfiguration:
        Enabled: true
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-create-group: true
            awslogs-group:
              !Join [
                "-",
                [!Ref ProjectName, !Ref EnvironmentName, "sc-history"],
              ]
            awslogs-region: !Ref AWS::Region
            awslogs-stream-prefix: ecs
        Namespace: !GetAtt PrivateDNSNamespace.Arn
        Services:
          - ClientAliases:
              - DnsName: !Ref HistoryServiceName
                Port: 80
            DiscoveryName: !Ref HistoryServiceName
            PortName: !Join ["-", [!Ref HistoryServiceName, "80", "tcp"]]
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref PrivateSubnet
          SecurityGroups:
            - !Ref ContainerSecurityGroup

  #===================================
  # ECS Task definitions
  #===================================
  TaskDefinitionQuestion:
    Type: "AWS::ECS::TaskDefinition"
    Properties:
      Family:
        !Join [
          "-",
          [!Ref ProjectName, !Ref EnvironmentName, "TaskDefinitionQuestion"],
        ]
      TaskRoleArn: !GetAtt ECSTaskRole.Arn
      ExecutionRoleArn: !GetAtt ECSTaskExecutionRole.Arn
      RequiresCompatibilities:
        - FARGATE
      ContainerDefinitions:
        - Name: !Ref QuestionServiceName
          Image:
            !If [
              UseNewRepo,
              !Join [
                "",
                [
                  !GetAtt ECRContainerRepo.RepositoryUri,
                  ":",
                  !Ref QuestionServiceName,
                ],
              ],
              008129720001.dkr.ecr.ap-southeast-1.amazonaws.com/peerprep-development-ecr-repo:question-service,
            ]
          Essential: true
          PortMappings:
            - ContainerPort: 80
              Protocol: tcp
              Name: !Join ["-", [!Ref QuestionServiceName, "80", "tcp"]]
          Environment:
            - Name: SERVICE_PORT
              Value: 80
            - Name: AUTH_GATEWAY
              Value: !Sub "http://${AuthServiceName}"
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-create-group: true
              awslogs-group:
                !Join [
                  "-",
                  [
                    !Ref ProjectName,
                    !Ref EnvironmentName,
                    !Ref QuestionServiceName,
                  ],
                ]
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs
      NetworkMode: awsvpc
      Memory: "512"
      Cpu: "256"

  TaskDefinitionMatching:
    Type: "AWS::ECS::TaskDefinition"
    Properties:
      Family:
        !Join [
          "-",
          [!Ref ProjectName, !Ref EnvironmentName, "TaskDefinitionMatching"],
        ]
      TaskRoleArn: !GetAtt ECSTaskRole.Arn
      ExecutionRoleArn: !GetAtt ECSTaskExecutionRole.Arn
      RequiresCompatibilities:
        - FARGATE
      ContainerDefinitions:
        - Name: !Ref MatchingServiceName
          Image:
            !If [
              UseNewRepo,
              !Join [
                "",
                [
                  !GetAtt ECRContainerRepo.RepositoryUri,
                  ":",
                  !Ref MatchingServiceName,
                ],
              ],
              008129720001.dkr.ecr.ap-southeast-1.amazonaws.com/peerprep-development-ecr-repo:matching-service,
            ]
          Essential: true
          PortMappings:
            - ContainerPort: 80
              Protocol: tcp
              Name: !Join ["-", [!Ref MatchingServiceName, "80", "tcp"]]
          Environment:
            - Name: SERVICE_PORT
              Value: 80
            - Name: EVENT_BUS_CONTAINER_NAME
              Value: !Ref EventBusName
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-create-group: true
              awslogs-group:
                !Join [
                  "-",
                  [
                    !Ref ProjectName,
                    !Ref EnvironmentName,
                    !Ref MatchingServiceName,
                  ],
                ]
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs
      NetworkMode: awsvpc
      Memory: "512"
      Cpu: "256"

  TaskDefinitionUser:
    Type: "AWS::ECS::TaskDefinition"
    Properties:
      Family:
        !Join [
          "-",
          [!Ref ProjectName, !Ref EnvironmentName, "TaskDefinitionUser"],
        ]
      TaskRoleArn: !GetAtt ECSTaskRole.Arn
      ExecutionRoleArn: !GetAtt ECSTaskExecutionRole.Arn
      RequiresCompatibilities:
        - FARGATE
      ContainerDefinitions:
        - Name: !Ref UserServiceName
          Image:
            !If [
              UseNewRepo,
              !Join [
                "",
                [
                  !GetAtt ECRContainerRepo.RepositoryUri,
                  ":",
                  !Ref UserServiceName,
                ],
              ],
              008129720001.dkr.ecr.ap-southeast-1.amazonaws.com/peerprep-development-ecr-repo:user-service,
            ]
          Essential: true
          PortMappings:
            - ContainerPort: 80
              Protocol: tcp
              Name: !Join ["-", [!Ref UserServiceName, "80", "tcp"]]
          Environment:
            - Name: SERVICE_PORT
              Value: 80
            - Name: AUTH_GATEWAY
              Value: !Sub "http://${AuthServiceName}"
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-create-group: true
              awslogs-group:
                !Join [
                  "-",
                  [
                    !Ref ProjectName,
                    !Ref EnvironmentName,
                    !Ref UserServiceName,
                  ],
                ]
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs
      NetworkMode: awsvpc
      Memory: "512"
      Cpu: "256"

  TaskDefinitionAuth:
    Type: "AWS::ECS::TaskDefinition"
    Properties:
      Family:
        !Join [
          "-",
          [!Ref ProjectName, !Ref EnvironmentName, "TaskDefinitionAuth"],
        ]
      TaskRoleArn: !GetAtt ECSTaskRole.Arn
      ExecutionRoleArn: !GetAtt ECSTaskExecutionRole.Arn
      RequiresCompatibilities:
        - FARGATE
      ContainerDefinitions:
        - Name: !Ref AuthServiceName
          Image:
            !If [
              UseNewRepo,
              !Join [
                "",
                [
                  !GetAtt ECRContainerRepo.RepositoryUri,
                  ":",
                  !Ref AuthServiceName,
                ],
              ],
              008129720001.dkr.ecr.ap-southeast-1.amazonaws.com/peerprep-development-ecr-repo:auth-service,
            ]
          Essential: true
          PortMappings:
            - ContainerPort: 80
              Protocol: tcp
              Name: !Join ["-", [!Ref AuthServiceName, "80", "tcp"]]
          Environment:
            - Name: SERVICE_PORT
              Value: 80
            - Name: USER_GATEWAY
              Value: !Sub "http://${UserServiceName}"
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-create-group: true
              awslogs-group:
                !Join [
                  "-",
                  [
                    !Ref ProjectName,
                    !Ref EnvironmentName,
                    !Ref AuthServiceName,
                  ],
                ]
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs
      NetworkMode: awsvpc
      Memory: "512"
      Cpu: "256"

  TaskDefinitionCollaboration:
    Type: "AWS::ECS::TaskDefinition"
    Properties:
      Family:
        !Join [
          "-",
          [
            !Ref ProjectName,
            !Ref EnvironmentName,
            "TaskDefinitionCollaboration",
          ],
        ]
      TaskRoleArn: !GetAtt ECSTaskRole.Arn
      ExecutionRoleArn: !GetAtt ECSTaskExecutionRole.Arn
      RequiresCompatibilities:
        - FARGATE
      ContainerDefinitions:
        - Name: !Ref CollaborationServiceName
          Image:
            !If [
              UseNewRepo,
              !Join [
                "",
                [
                  !GetAtt ECRContainerRepo.RepositoryUri,
                  ":",
                  !Ref CollaborationServiceName,
                ],
              ],
              008129720001.dkr.ecr.ap-southeast-1.amazonaws.com/peerprep-development-ecr-repo:collaboration-service,
            ]
          Essential: true
          PortMappings:
            - ContainerPort: 80
              Protocol: tcp
              Name: !Join ["-", [!Ref CollaborationServiceName, "80", "tcp"]]
          Environment:
            - Name: SERVICE_PORT
              Value: 80
            - Name: EVENT_BUS_CONTAINER_NAME
              Value: !Ref EventBusName
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-create-group: true
              awslogs-group:
                !Join [
                  "-",
                  [
                    !Ref ProjectName,
                    !Ref EnvironmentName,
                    !Ref CollaborationServiceName,
                  ],
                ]
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs
        - Name: "collaboration-cache"
          Image:
            !If [
              UseNewRepo,
              !Join [
                "",
                [
                  !GetAtt ECRContainerRepo.RepositoryUri,
                  ":",
                  "collaboration-cache",
                ],
              ],
              008129720001.dkr.ecr.ap-southeast-1.amazonaws.com/peerprep-development-ecr-repo:collaboration-cache,
            ]
          Essential: true
          PortMappings:
            - ContainerPort: 6379
              Protocol: tcp
              Name: !Join ["-", ["collaboration-cache", "6379", "tcp"]]
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-create-group: true
              awslogs-group:
                !Join [
                  "-",
                  [
                    !Ref ProjectName,
                    !Ref EnvironmentName,
                    "collaboration-cache",
                  ],
                ]
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs
      NetworkMode: awsvpc
      Memory: "1024"
      Cpu: "256"

  TaskDefinitionEventBus:
    Type: "AWS::ECS::TaskDefinition"
    Properties:
      Family:
        !Join [
          "-",
          [!Ref ProjectName, !Ref EnvironmentName, "TaskDefinitionEventBus"],
        ]
      TaskRoleArn: !GetAtt ECSTaskRole.Arn
      ExecutionRoleArn: !GetAtt ECSTaskExecutionRole.Arn
      RequiresCompatibilities:
        - FARGATE
      ContainerDefinitions:
        - Name: !Ref EventBusName
          Image:
            !If [
              UseNewRepo,
              !Join [
                "",
                [
                  !GetAtt ECRContainerRepo.RepositoryUri,
                  ":",
                  !Ref EventBusName,
                ],
              ],
              008129720001.dkr.ecr.ap-southeast-1.amazonaws.com/peerprep-development-ecr-repo:event-bus,
            ]
          Essential: true
          PortMappings:
            - ContainerPort: 6379
              HostPort: 6379
              Protocol: tcp
              Name: !Join ["-", [!Ref EventBusName, "6379", "tcp"]]
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-create-group: true
              awslogs-group:
                !Join [
                  "-",
                  [!Ref ProjectName, !Ref EnvironmentName, !Ref EventBusName],
                ]
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs
      NetworkMode: awsvpc
      Memory: "1024"
      Cpu: "256"

  TaskDefinitionHistory:
    Type: "AWS::ECS::TaskDefinition"
    Properties:
      Family:
        !Join [
          "-",
          [!Ref ProjectName, !Ref EnvironmentName, "TaskDefinitionHistory"],
        ]
      TaskRoleArn: !GetAtt ECSTaskRole.Arn
      ExecutionRoleArn: !GetAtt ECSTaskExecutionRole.Arn
      RequiresCompatibilities:
        - FARGATE
      ContainerDefinitions:
        - Name: !Ref HistoryServiceName
          Image:
            !If [
              UseNewRepo,
              !Join [
                "",
                [
                  !GetAtt ECRContainerRepo.RepositoryUri,
                  ":",
                  !Ref HistoryServiceName,
                ],
              ],
              008129720001.dkr.ecr.ap-southeast-1.amazonaws.com/peerprep-development-ecr-repo:history-service,
            ]
          Essential: true
          PortMappings:
            - ContainerPort: 80
              Protocol: tcp
              Name: !Join ["-", [!Ref HistoryServiceName, "80", "tcp"]]
          Environment:
            - Name: SERVICE_PORT
              Value: 80
            - Name: AUTH_GATEWAY
              Value: !Sub "http://${AuthServiceName}"
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-create-group: true
              awslogs-group:
                !Join [
                  "-",
                  [!Ref ProjectName, !Ref EnvironmentName, "history-service"],
                ]
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs
      NetworkMode: awsvpc
      Memory: "512"
      Cpu: "256"

  #===================================
  # ECR Image Repo
  #===================================
  ECRContainerRepo:
    Type: "AWS::ECR::Repository"
    Properties:
      RepositoryName:
        !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "ecr-repo"]]
      EmptyOnDelete: true
      LifecyclePolicy:
        LifecyclePolicyText: '{"rules":[{"rulePriority":1,"description":"remove old images","selection":{"tagStatus":"untagged","countType":"imageCountMoreThan","countNumber":5},"action":{"type":"expire"}}]}'

  #===================================
  # ECS Autoscaling
  #===================================
  AutoScalingTargetQuestion:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MinCapacity: !Ref MinContainers
      MaxCapacity: !Ref MaxContainers
      ResourceId:
        !Join ["/", [service, !Ref ECSCluster, !GetAtt ServiceQuestion.Name]]
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs
      RoleARN: !GetAtt AutoScalingRole.Arn

  AutoScalingTargetMatching:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MinCapacity: !Ref MinContainers
      MaxCapacity: !Ref MaxContainers
      ResourceId:
        !Join ["/", [service, !Ref ECSCluster, !GetAtt ServiceMatching.Name]]
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs
      RoleARN: !GetAtt AutoScalingRole.Arn

  AutoScalingTargetAuth:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MinCapacity: !Ref MinContainers
      MaxCapacity: !Ref MaxContainers
      ResourceId:
        !Join ["/", [service, !Ref ECSCluster, !GetAtt ServiceAuth.Name]]
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs
      RoleARN: !GetAtt AutoScalingRole.Arn

  AutoScalingTargetUser:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MinCapacity: !Ref MinContainers
      MaxCapacity: !Ref MaxContainers
      ResourceId:
        !Join ["/", [service, !Ref ECSCluster, !GetAtt ServiceUser.Name]]
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs
      RoleARN: !GetAtt AutoScalingRole.Arn

  AutoScalingTargetCollaboration:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MinCapacity: !Ref MinContainers
      MaxCapacity: !Ref MaxContainers
      ResourceId:
        !Join [
          "/",
          [service, !Ref ECSCluster, !GetAtt ServiceCollaboration.Name],
        ]
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs
      RoleARN: !GetAtt AutoScalingRole.Arn

  AutoScalingTargetHistory:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MinCapacity: !Ref MinContainers
      MaxCapacity: !Ref MaxContainers
      ResourceId:
        !Join ["/", [service, !Ref ECSCluster, !GetAtt ServiceHistory.Name]]
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs
      RoleARN: !GetAtt AutoScalingRole.Arn

  AutoScalingPolicyQuestion:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName:
        !Join ["", [!GetAtt ServiceQuestion.Name, "-AutoScalingPolicy"]]
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref AutoScalingTargetQuestion
      TargetTrackingScalingPolicyConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageCPUUtilization
        TargetValue: !Ref AutoScalingTargetValue

  AutoScalingPolicyMatching:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName:
        !Join ["", [!GetAtt ServiceMatching.Name, "-AutoScalingPolicy"]]
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref AutoScalingTargetMatching
      TargetTrackingScalingPolicyConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageCPUUtilization
        TargetValue: !Ref AutoScalingTargetValue

  AutoScalingPolicyAuth:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: !Join ["", [!GetAtt ServiceAuth.Name, "-AutoScalingPolicy"]]
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref AutoScalingTargetAuth
      TargetTrackingScalingPolicyConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageCPUUtilization
        TargetValue: !Ref AutoScalingTargetValue

  AutoScalingPolicyUser:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: !Join ["", [!GetAtt ServiceUser.Name, "-AutoScalingPolicy"]]
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref AutoScalingTargetUser
      TargetTrackingScalingPolicyConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageCPUUtilization
        TargetValue: !Ref AutoScalingTargetValue

  AutoScalingPolicyCollaboration:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName:
        !Join ["", [!GetAtt ServiceCollaboration.Name, "-AutoScalingPolicy"]]
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref AutoScalingTargetCollaboration
      TargetTrackingScalingPolicyConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageCPUUtilization
        TargetValue: !Ref AutoScalingTargetValue

  AutoScalingPolicyHistory:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName:
        !Join ["", [!GetAtt ServiceHistory.Name, "-AutoScalingPolicy"]]
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref AutoScalingTargetHistory
      TargetTrackingScalingPolicyConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageCPUUtilization
        TargetValue: !Ref AutoScalingTargetValue

  #===================================
  # Cognito
  #===================================
  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UsernameAttributes:
        - email
      AutoVerifiedAttributes:
        - email

  UserPoolClient:
    Type: "AWS::Cognito::UserPoolClient"
    Properties:
      UserPoolId: !Ref UserPool
      GenerateSecret: false
      SupportedIdentityProviders:
        - COGNITO
      PreventUserExistenceErrors: ENABLED

  #===================================
  # API Gateway
  #===================================
  HttpApi:
    Type: "AWS::ApiGatewayV2::Api"
    Properties:
      Name: !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "HttpApi"]]
      ProtocolType: "HTTP"
      RouteSelectionExpression: "$request.method $request.path"
      CorsConfiguration:
        AllowHeaders:
          - "*"
        AllowMethods:
          - "PUT"
          - "GET"
          - "POST"
          - "DELETE"
        AllowOrigins:
          - !Sub "https://${EnvironmentName}.d2wfcislijzove.amplifyapp.com"
          - "https://amplify.d2wfcislijzove.amplifyapp.com"
          - "http://localhost:3000"
      DisableExecuteApiEndpoint: false

  # Route for Question
  RouteQuestionApiHealth:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "GET /question/api/health"
      Target: !Sub "integrations/${IntegrationQuestion}"
  RouteQuestionApiTopics:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "GET /question/api/topics"
      Target: !Sub "integrations/${IntegrationQuestion}"
  RouteQuestionApiQuestions:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "GET /question/api/questions"
      Target: !Sub "integrations/${IntegrationQuestion}"
  RouteQuestionApiQuestionById:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "GET /question/api/questions/{questionId}"
      Target: !Sub "integrations/${IntegrationQuestion}"
  RouteQuestionApiPostQuestion:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "POST /question/api/questions"
      Target: !Sub "integrations/${IntegrationQuestion}"
  RouteQuestionApiUpdateQuestion:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "PUT /question/api/questions/{questionId}"
      Target: !Sub "integrations/${IntegrationQuestion}"
  RouteQuestionApiDeleteQuestion:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "DELETE /question/api/questions/{questionId}"
      Target: !Sub "integrations/${IntegrationQuestion}"

  # Route for matching
  RouteMatchingSocket:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "ANY /matching/socket/{proxy}"
      Target: !Sub "integrations/${IntegrationMatching}"
  RouteMatchingApiStatus:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "GET /matching/api/status"
      Target: !Sub "integrations/${IntegrationMatching}"
  RouteMatchingApiHealth:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "GET /matching/api/health"
      Target: !Sub "integrations/${IntegrationMatching}"

  # Route for Auth
  RouteAuthApiHealth:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "GET /auth/api/health"
      Target: !Sub "integrations/${IntegrationAuth}"
  RouteAuthApiVerifyResetPasswordLinkValidity:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "GET /auth/api/verifyResetPasswordLinkValidity/{id}/{token}"
      Target: !Sub "integrations/${IntegrationAuth}"
  RouteAuthApiRegisterByEmail:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "POST /auth/api/registerByEmail"
      Target: !Sub "integrations/${IntegrationAuth}"
  RouteAuthApiLoginByEmail:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "POST /auth/api/loginByEmail"
      Target: !Sub "integrations/${IntegrationAuth}"
  RouteAuthApiValidate:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "POST /auth/api/validate"
      Target: !Sub "integrations/${IntegrationAuth}"
  RouteAuthApiValidateAdmin:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "POST /auth/api/validateAdmin"
      Target: !Sub "integrations/${IntegrationAuth}"
  RouteAuthApiLogout:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "POST /auth/api/logout"
      Target: !Sub "integrations/${IntegrationAuth}"
  RouteAuthApiVerifyEmail:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "PUT /auth/api/verifyEmail/{email}/{token}"
      Target: !Sub "integrations/${IntegrationAuth}"
  RouteAuthApiResendVerificationEmail:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "PUT /auth/api/resendVerificationEmail/{email}"
      Target: !Sub "integrations/${IntegrationAuth}"
  RouteAuthApiSendPasswordResetEmail:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "PUT /auth/api/sendPasswordResetEmail/{email}"
      Target: !Sub "integrations/${IntegrationAuth}"
  RouteAuthApiChangePassword:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "PUT /auth/api/changePassword/{id}"
      Target: !Sub "integrations/${IntegrationAuth}"

  # Route for User
  RouteUserApiHealth:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "GET /user/api/health"
      Target: !Sub "integrations/${IntegrationUser}"
  RouteUserApiEmail:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "GET /user/api/users/email"
      Target: !Sub "integrations/${IntegrationUser}"
  RouteUserApiUserById:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "GET /user/api/users/{userId}"
      Target: !Sub "integrations/${IntegrationUser}"
  RouteUserApiUserPreferences:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "GET /user/api/users/{userId}/preferences"
      Target: !Sub "integrations/${IntegrationUser}"
  RouteUserApiUpdateUserPreferences:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "PUT /user/api/users/{userId}/preferences"
      Target: !Sub "integrations/${IntegrationUser}"
  RouteUserApiPostUser:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "POST /user/api/users"
      Target: !Sub "integrations/${IntegrationUser}"
  RouteUserApiUpdateUserById:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "PUT /user/api/users/{userId}"
      Target: !Sub "integrations/${IntegrationUser}"
  RouteUserApiDeleteUserById:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "DELETE /user/api/users/{userId}"
      Target: !Sub "integrations/${IntegrationUser}"

  # Route for collaboration
  RouteCollaborationSocket:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "ANY /collaboration/socket/{proxy}"
      Target: !Sub "integrations/${IntegrationCollaboration}"

  # Route for History
  RouteHistoryApiHealth:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "GET /history/api/health"
      Target: !Sub "integrations/${IntegrationHistory}"
  RouteHistoryApiGetHistory:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "GET /history/api/history"
      Target: !Sub "integrations/${IntegrationHistory}"
  RouteHistoryApiPostHistory:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "POST /history/api/history"
      Target: !Sub "integrations/${IntegrationHistory}"
  RouteHistoryApiDeleteHistory:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "DELETE /history/api/history/user/{userId}/question/{questionId}"
      Target: !Sub "integrations/${IntegrationHistory}"
  RouteHistoryApiGetQuestionCodeHistory:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "GET /history/api/history/user/{userId}/question/{questionId}/code"
      Target: !Sub "integrations/${IntegrationHistory}"
  RouteHistoryApiUpdateQuestionCodeSubmission:
    Type: "AWS::ApiGatewayV2::Route"
    Properties:
      ApiId: !Ref HttpApi
      ApiKeyRequired: false
      AuthorizationType: "NONE"
      RequestParameters: {}
      RouteKey: "PUT /history/api/history/user/{userId}/question/{questionId}/code"
      Target: !Sub "integrations/${IntegrationHistory}"

  # API Gateway integrations
  IntegrationQuestion:
    Type: "AWS::ApiGatewayV2::Integration"
    Properties:
      ApiId: !Ref HttpApi
      Description:
        !Join [
          "-",
          [!Ref ProjectName, !Ref EnvironmentName, "IntegrationQuestion"],
        ]
      ConnectionType: "VPC_LINK"
      ConnectionId: !Ref HttpApiVPCLink
      IntegrationMethod: "ANY"
      IntegrationType: "HTTP_PROXY"
      IntegrationUri: !GetAtt ServiceDiscoveryQuestion.Arn
      PayloadFormatVersion: "1.0"
  IntegrationMatching:
    Type: "AWS::ApiGatewayV2::Integration"
    Properties:
      ApiId: !Ref HttpApi
      Description:
        !Join [
          "-",
          [!Ref ProjectName, !Ref EnvironmentName, "IntegrationMatching"],
        ]
      ConnectionType: "VPC_LINK"
      ConnectionId: !Ref HttpApiVPCLink
      IntegrationMethod: "ANY"
      IntegrationType: "HTTP_PROXY"
      IntegrationUri: !GetAtt ServiceDiscoveryMatching.Arn
      PayloadFormatVersion: "1.0"
  IntegrationAuth:
    Type: "AWS::ApiGatewayV2::Integration"
    Properties:
      ApiId: !Ref HttpApi
      Description:
        !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "IntegrationAuth"]]
      ConnectionType: "VPC_LINK"
      ConnectionId: !Ref HttpApiVPCLink
      IntegrationMethod: "ANY"
      IntegrationType: "HTTP_PROXY"
      IntegrationUri: !GetAtt ServiceDiscoveryAuth.Arn
      PayloadFormatVersion: "1.0"
  IntegrationUser:
    Type: "AWS::ApiGatewayV2::Integration"
    Properties:
      ApiId: !Ref HttpApi
      Description:
        !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "IntegrationUser"]]
      ConnectionType: "VPC_LINK"
      ConnectionId: !Ref HttpApiVPCLink
      IntegrationMethod: "ANY"
      IntegrationType: "HTTP_PROXY"
      IntegrationUri: !GetAtt ServiceDiscoveryUser.Arn
      PayloadFormatVersion: "1.0"
  IntegrationCollaboration:
    Type: "AWS::ApiGatewayV2::Integration"
    Properties:
      ApiId: !Ref HttpApi
      Description:
        !Join [
          "-",
          [!Ref ProjectName, !Ref EnvironmentName, "IntegrationCollaboration"],
        ]
      ConnectionType: "VPC_LINK"
      ConnectionId: !Ref HttpApiVPCLink
      IntegrationMethod: "ANY"
      IntegrationType: "HTTP_PROXY"
      IntegrationUri: !GetAtt ServiceDiscoveryCollaboration.Arn
      PayloadFormatVersion: "1.0"
  IntegrationHistory:
    Type: "AWS::ApiGatewayV2::Integration"
    Properties:
      ApiId: !Ref HttpApi
      Description:
        !Join [
          "-",
          [!Ref ProjectName, !Ref EnvironmentName, "IntegrationHistory"],
        ]
      ConnectionType: "VPC_LINK"
      ConnectionId: !Ref HttpApiVPCLink
      IntegrationMethod: "ANY"
      IntegrationType: "HTTP_PROXY"
      IntegrationUri: !GetAtt ServiceDiscoveryHistory.Arn
      PayloadFormatVersion: "1.0"

  HttpApiStage:
    Type: "AWS::ApiGatewayV2::Stage"
    Properties:
      StageName: "$default"
      ApiId: !Ref "HttpApi"
      AutoDeploy: true

  HttpApiVPCLink:
    Type: AWS::ApiGatewayV2::VpcLink
    Properties:
      Name: !Join ["-", [!Ref ProjectName, !Ref EnvironmentName, "vpclink"]]
      SecurityGroupIds:
        - !Ref ContainerSecurityGroup
      SubnetIds:
        - !Ref PrivateSubnet

Outputs:
  APIInvokeURL:
    Description: Invoke URL for the HTTP API
    Value: !Sub "https://${HttpApi}.execute-api.${AWS::Region}.amazonaws.com"
  APIId:
    Description: The ID of the HTTP API
    Value: !Ref "HttpApi"
  ECSContainerRepo:
    Description: The name of the ECR repo
    Value: !Ref "ECRContainerRepo"
  ECSClusterName:
    Description: The name of the ECS cluster
    Value: !Ref "ECSCluster"
  VpcId:
    Description: The ID of the VPC that this stack is deployed in
    Value: !Ref "VPC"
  ContainerSecurityGroup:
    Description: A security group used to allow Fargate containers to receive traffic
    Value: !Ref "ContainerSecurityGroup"
  PrivateDNSNamespace:
    Description: The ID of the private DNS namespace.
    Value: !Ref "PrivateDNSNamespace"
