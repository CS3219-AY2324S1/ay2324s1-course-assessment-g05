[
  {
    "id": "1",
    "title": "Reverse a String",
    "topics": ["String", "Two Pointers"],
    "complexity": "Easy",
    "url": "https://leetcode.com/problems/reverse-string/",
    "description": "Write a function that reverses a string. The input string is given as an array of characters char[]. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.",
    "examples": [
      {
        "input": "['h','e','l','l','o']",
        "output": "['o','l','l','e','h']"
      },
      {
        "input": "['H','a','n','n','a','h']",
        "output": "['h','a','n','n','a','H']"
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^5",
      "s[i] is a printable ascii character."
    ]
  },
  {
    "id": "2",
    "title": "Linked List Cycle Detection",
    "topics": ["Hash Table", "Two Pointers", "Linked List"],
    "complexity": "Easy",
    "url": "https://leetcode.com/problems/linked-list-cycle/",
    "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\nReturn true if there is a cycle in the linked list. Otherwise, return false.",
    "examples": [
      {
        "input": "head = [3,2,0,-4], pos = 1",
        "output": "true",
        "explanation": "There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed)."
      },
      {
        "input": "head = [1,2], pos = 0",
        "output": "true",
        "explanation": "There is a cycle in the linked list, where the tail connects to the 0th node."
      },
      {
        "input": "head = [1], pos = -1",
        "output": "false",
        "explanation": "There is no cycle in the linked list."
      }
    ],
    "constraints": [
      "The number of the nodes in the list is in the range [0, 10^4].",
      "-10^5 <= Node.val <= 10^5",
      "pos is -1 or a valid index in the linked-list."
    ]
  },
  {
    "id": "3",
    "title": "Roman to Integer",
    "topics": ["Math", "String"],
    "complexity": "Easy",
    "url": "https://leetcode.com/problems/roman-to-integer/",
    "description": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9.\nX can be placed before L (50) and C (100) to make 40 and 90.\nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer.",
    "examples": [
      {
        "input": "\"III\"",
        "output": "3",
        "explanation": "III=3"
      },
      {
        "input": "\"LVIII\"",
        "output": "58",
        "explanation": "L = 50, V= 5, III = 3."
      },
      {
        "input": "\"MCMXCIV\"",
        "output": "1994",
        "explanation": "M = 1000, CM = 900, XC = 90 and IV = 4."
      }
    ],
    "constraints": [
      "1 <= s.length <= 15",
      "s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').",
      "It is guaranteed that s is a valid roman numeral in the range [1, 3999]."
    ]
  },
  {
    "id": "4",
    "title": "Add Binary",
    "topics": ["Math", "String", "Bit Manipulation"],
    "complexity": "Easy",
    "url": "https://leetcode.com/problems/add-binary/",
    "description": "Given two binary strings a and b, return their sum as a binary string.",
    "examples": [
      {
        "input": "a = \"11\", b = \"1\"",
        "output": "\"100\""
      },
      {
        "input": "a = \"1010\", b = \"1011\"",
        "output": "\"10101\""
      }
    ],
    "constraints": [
      "1 <= a.length, b.length <= 10^4",
      "a and b consist only of '0' or '1' characters.",
      "Each string does not contain leading zeros except for the zero itself."
    ]
  },
  {
    "id": "5",
    "title": "Fibonacci Number",
    "topics": ["Math", "Dynamic Programming", "Recursion", "Memoization"],
    "complexity": "Easy",
    "url": "https://leetcode.com/problems/fibonacci-number/",
    "description": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\nGiven n, calculate F(n).",
    "examples": [
      {
        "input": "n = 2",
        "output": "1",
        "explanation": "F(2) = F(1) + F(0) = 1 + 0 = 1."
      },
      {
        "input": "n = 3",
        "output": "2",
        "explanation": "F(3) = F(2) + F(1) = 1 + 1 = 2."
      },
      {
        "input": "n = 4",
        "output": "3",
        "explanation": "F(4) = F(3) + F(2) = 2 + 1 = 3."
      }
    ],
    "constraints": ["0 <= n <= 30"]
  },
  {
    "id": "6",
    "title": "Implement Stack using Queues",
    "topics": ["Stack", "Queue"],
    "complexity": "Easy",
    "url": "https://leetcode.com/problems/implement-stack-using-queues/",
    "description": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).\nImplement the MyStack class:\nvoid push(int x) Pushes element x to the top of the stack.\nint pop() Removes the element on the top of the stack and returns it.\nint top() Returns the element on the top of the stack.\nboolean empty() Returns true if the stack is empty, false otherwise.\nNotes:\nYou must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.",
    "examples": [
      {
        "input": "[\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
        "output": "[null, null, null, 2, 2, false]"
      },
      {
        "input": "[\"MyStack\", \"push\", \"push\", \"push\", \"pop\", \"top\"]\n[[], [1], [2], [3], [], []]",
        "output": "[null, null, null, null, 3, 2]"
      }
    ],
    "constraints": [
      "1 <= x <= 9",
      "At most 100 calls will be made to push, pop, top, and empty.",
      "All the calls to pop and top are valid."
    ]
  },
  {
    "id": "7",
    "title": "Combine Two Tables",
    "topics": ["Databases"],
    "complexity": "Easy",
    "url": "https://leetcode.com/problems/combine-two-tables/",
    "description": "SQL Schema\nTable: Person\n+-------------+---------+\n| Column Name | Type |\n+-------------+---------+\n| personId | int |\n| lastName | varchar |\n| firstName | varchar |\n+-------------+---------+personId is the primary key (column with unique values) for this table.This table contains information about the ID of some persons and their firstand last names.\nTable: Address\n+-------------+---------+\n| Column Name | Type |\n+-------------+---------+\n| addressId | int |\n| personId | int |\n| city | varchar |\n| state | varchar |\n+-------------+---------+\naddressId is the primary key (column with unique values) for this table.Each row of this table contains information about the city and state of oneperson with ID = PersonId.\nWrite an SQL query to report the first name, last name, city, and state of each person in the Person table. If the address of a PersonId is not present in the Address table, report null instead.\nReturn the result table in any order.\nThe result format is in the following example.",
    "examples": [
      {
        "input": "Person table:\n+----------+----------+-----------+\n| personId | lastName | firstName |\n+----------+----------+-----------+\n| 1 | Wang | Allen |\n| 2 | Alice | Bob |\n+----------+----------+-----------+Address table:\n+-----------+----------+----------+------------+\n| addressId | personId | city | state |\n+-----------+----------+----------+------------+\n| 1 | 2 | New York | New York |\n| 2 | 3 | Leetcode | California |\n+-----------+----------+----------+------------+Output table:\n+-----------+----------+----------+------------+\n| firstName | lastName | city | state |\n+-----------+----------+----------+------------+\n| Allen | Wang | null | null |\n| Bob | Alice | New York | New York |\n+-----------+----------+----------+------------+",
        "output": "+-----------+----------+---------------+----------+\n| firstName | lastName | city | state |\n+-----------+----------+---------------+----------+\n| Allen | Wang | Null | Null |\n| Bob | Alice | New York City | New York |\n+-----------+----------+---------------+----------+",
        "explanation": "There is no address in the address table for the personId = 1 so we return null in their city and state.\naddressId = 1 contains information about the address of personId = 2."
      }
    ],
    "constraints": [
      "1 <= personId <= 9",
      "1 <= addressId <= 9",
      "lastName and firstName consist of lowercase English letters.",
      "city and state consist of lowercase English letters.",
      "Each personId in the Person table is unique.",
      "Each addressId in the Address table belongs to a personId in the Person table."
    ]
  },
  {
    "id": "8",
    "title": "Repeated DNA Sequences",
    "topics": ["Bit Manipulation", "Hash Table", "String", "Sliding Window"],
    "complexity": "Medium",
    "url": "https://leetcode.com/problems/repeated-dna-sequences/",
    "description": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.\nFor example, \"ACGAATTCCG\" is a DNA sequence.\nWhen studying DNA, it is useful to identify repeated sequences within the DNA.\nGiven a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.",
    "examples": [
      {
        "input": "\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"",
        "output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]"
      },
      {
        "input": "\"AAAAAAAAAAAAA\"",
        "output": "[\"AAAAAAAAAA\"]"
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^5",
      "s[i] is either 'A', 'C', 'G', or 'T'."
    ]
  },
  {
    "id": "9",
    "title": "Course Schedule",
    "topics": [
      "Graphs",
      "Depth-First Search",
      "Breadth-First Search",
      "Topological Sort"
    ],
    "complexity": "Medium",
    "url": "https://leetcode.com/problems/course-schedule/",
    "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\nReturn true if you can finish all courses. Otherwise, return false.",
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = [[1,0]]",
        "output": "true",
        "explanation": "There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
        "output": "false",
        "explanation": "There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible."
      }
    ],
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= ai, bi < numCourses",
      "All the pairs prerequisites[i] are unique."
    ]
  },
  {
    "id": "10",
    "title": "LRU Cache Design",
    "topics": ["Hash Table", "Linked List"],
    "complexity": "Medium",
    "url": "https://leetcode.com/problems/lru-cache/",
    "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\nThe functions get and put must each run in O(1) average time complexity.",
    "examples": [
      {
        "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
        "output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
        "explanation": "LRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1); // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2); // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1); // return -1 (not found)\nlRUCache.get(3); // return 3\nlRUCache.get(4); // return 4"
      }
    ],
    "constraints": [
      "1 <= capacity <= 3000",
      "0 <= key <= 10^4",
      "0 <= value <= 10^5",
      "At most 2 * 10^5 calls will be made to get and put."
    ]
  },
  {
    "id": "11",
    "title": "Longest Common Subsequence",
    "topics": ["Strings", "Dynamic Programming"],
    "complexity": "Medium",
    "url": "https://leetcode.com/problems/longest-common-subsequence/",
    "description": "Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\nFor example, \"ace\" is a subsequence of \"abcde\".\nA common subsequence of two strings is a subsequence that is common to both strings.",
    "examples": [
      {
        "input": "text1 = \"abcde\", text2 = \"ace\"",
        "output": "3",
        "explanation": "The longest common subsequence is \"ace\" and its length is 3."
      },
      {
        "input": "text1 = \"abc\", text2 = \"abc\"",
        "output": "3",
        "explanation": "The longest common subsequence is \"abc\" and its length is 3."
      },
      {
        "input": "text1 = \"abc\", text2 = \"def\"",
        "output": "0",
        "explanation": "There is no such common subsequence, so the result is 0."
      }
    ],
    "constraints": [
      "1 <= text1.length, text2.length <= 1000",
      "text1 and text2 consist of only lowercase English characters."
    ]
  },
  {
    "id": "12",
    "title": "Rotate Image",
    "topics": ["Array", "Math", "Matrix"],
    "complexity": "Medium",
    "url": "https://leetcode.com/problems/rotate-image/",
    "description": "You are given an nxn 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.",
    "examples": [
      {
        "input": "[[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]"
      },
      {
        "input": "[[1,2],[3,4]]",
        "output": "[[3,1],[4,2]]"
      },
      {
        "input": "[[1]]",
        "output": "[[1]]"
      },
      {
        "input": "[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]",
        "output": "[[13,9,5,1],[14,10,6,2],[15,11,7,3],[16,12,8,4]]"
      }
    ],
    "constraints": [
      "matrix.length == n",
      "matrix[i].length == n",
      "1 <= n <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ]
  },
  {
    "id": "13",
    "title": "Airplane Seat Assignment Probability",
    "topics": ["Brain Teaser", "Dynamic Programming", "Math"],
    "complexity": "Medium",
    "url": "https://leetcode.com/problems/airplane-seat-assignment-probability/",
    "description": "n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after tha, the rest of the passengers will:\nTake their own seat if it is still available, Pick other seats randomly when they find their seat occupied\nWhat is the probability that the n-th person can get his own seat?",
    "examples": [
      {
        "input": "n = 1",
        "output": "1.00000",
        "explanation": "The first person can only get the first seat."
      },
      {
        "input": "n = 2",
        "output": "0.50000",
        "explanation": "The second person has a probability of 0.5 to get the second seat (when first person gets the first seat)."
      }
    ],
    "constraints": ["1 <= n <= 10^5"]
  },
  {
    "id": "14",
    "title": "Validate Binary Search Tree",
    "topics": ["Tree", "Binary Tree", "Depth-First Search"],
    "complexity": "Medium",
    "url": "https://leetcode.com/problems/validate-binary-search-tree/",
    "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.",
    "examples": [
      {
        "input": "[2,1,3]",
        "output": "true"
      },
      {
        "input": "[5,1,4,null,null,3,6]",
        "output": "false"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [1, 10^4].",
      "-2^31 <= Node.val <= 2^31 - 1"
    ]
  },
  {
    "id": "15",
    "title": "Sliding Window Maximum",
    "topics": ["Sliding Window", "Queue", "Array", "Heap (Priority Queue)"],
    "complexity": "Hard",
    "url": "https://leetcode.com/problems/sliding-window-maximum/",
    "description": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the max sliding window.",
    "examples": [
      {
        "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
        "output": "[3,3,5,5,6,7]",
        "explanation": "Window position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7"
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]"
      },
      {
        "input": "nums = [1,-1], k = 1",
        "output": "[1,-1]"
      },
      {
        "input": "nums = [9,11], k = 2",
        "output": "[11]"
      },
      {
        "input": "nums = [4,-2], k = 2",
        "output": "[4]"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "1 <= k <= nums.length"
    ]
  },
  {
    "id": "16",
    "title": "N-Queen Problem",
    "topics": ["Backtracking", "Recursion"],
    "complexity": "Hard",
    "url": "https://leetcode.com/problems/n-queens/",
    "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.",
    "examples": [
      {
        "input": "n = 4",
        "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]",
        "explanation": "There exists two distinct solutions to the 4-queens puzzle as shown above"
      },
      {
        "input": "n = 1",
        "output": "[[\"Q\"]]"
      }
    ],
    "constraints": ["1 <= n <= 9"]
  },
  {
    "id": "17",
    "title": "Serialize and Deserialize a Binary Tree",
    "topics": ["Tree", "Binary Tree", "Breadth-First Search"],
    "complexity": "Hard",
    "url": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
    "description": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.",
    "examples": [
      {
        "input": "[1,2,3,null,null,4,5]",
        "output": "[1,2,3,null,null,4,5]"
      },
      {
        "input": "[]",
        "output": "[]"
      },
      {
        "input": "[1]",
        "output": "[1]"
      },
      {
        "input": "[1,2]",
        "output": "[1,2]"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "-1000 <= Node.val <= 1000"
    ]
  },
  {
    "id": "18",
    "title": "Wildcard Matching",
    "topics": ["String", "Dynamic Programming", "Backtracking", "Greedy"],
    "complexity": "Hard",
    "url": "https://leetcode.com/problems/wildcard-matching/",
    "description": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n'?' Matches any single character.\n'*' Matches any sequence of characters (including the empty sequence).\nThe matching should cover the entire input string (not partial).",
    "examples": [
      {
        "input": "s = \"aa\", p = \"a\"",
        "output": "false",
        "explanation": "\"a\" does not match the entire string \"aa\"."
      },
      {
        "input": "s = \"aa\", p = \"*\"",
        "output": "true",
        "explanation": " '*' matches any sequence."
      },
      {
        "input": "s = \"cb\", p = \"?a\"",
        "output": "false",
        "explanation": "\"b\" does not match the second character of \"cb\"."
      },
      {
        "input": "s = \"acdcb\", p = \"a*c?b\"",
        "output": "false",
        "explanation": "\"a\" does not match the second character of \"acdcb\"."
      }
    ],
    "constraints": [
      "0 <= s.length, p.length <= 2000",
      "s contains only lowercase English letters.",
      "p contains only lowercase English letters, '?' or '*'."
    ]
  },
  {
    "id": "19",
    "title": "Chalkboard XOR Game",
    "topics": ["Brain Teaser", "Math", "Bit Manipulation", "Array"],
    "complexity": "Hard",
    "url": "https://leetcode.com/problems/chalkboard-xor-game/",
    "description": "You are given an array of integers nums represents the numbers written on a chalkboard.\nAlice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first. If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses. The bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.\nAlso, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins.\nReturn true if and only if Alice wins the game, assuming both players play optimally.",
    "examples": [
      {
        "input": "nums = [1,1,2]",
        "output": "false",
        "explanation": "Alice has two choices: erase 1 or erase 2. If she erases 1, the nums array becomes [1,2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose. If Alice erases 2 first, now nums becomes [1,1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose."
      },
      {
        "input": "nums = [0,1]",
        "output": "true"
      },
      {
        "input": "nums = [1,2,3]",
        "output": "true"
      },
      {
        "input": "nums = [1,1,1,2]",
        "output": "false"
      },
      {
        "input": "nums = [1,1,2,3,5,6,7]",
        "output": "true"
      }
    ],
    "constraints": ["1 <= nums.length <= 1000", "0 <= nums[i] < 2^16"]
  },
  {
    "id": "20",
    "title": "Trips and Users",
    "topics": ["Databases"],
    "complexity": "Hard",
    "url": "https://leetcode.com/problems/trips-and-users/",
    "description": "SQL Schema\nPandas Schema\nTable:Trips\n+-------------+---------+\n| Column Name | Type |\n+-------------+---------+\n| Id | int |\n| Client_Id | int |\n| Driver_Id | int |\n| City_Id | int |\n| Status | enum |\n| Request_at | date |\n+-------------+---------+\nId is the primary key for this table.\nThe table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are foreign keys to the Users_Id at the Users table.\nStatus is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’).\nTable: Users\n+-------------+---------+\n| Column Name | Type |\n+-------------+---------+\n| Users_Id | int |\n| Banned | enum |\n| Role | enum |\n+-------------+---------+\nUsers_Id is the primary key for this table.\nThe table holds all users. Each user has a unique Users_Id, and Role is an ENUM type of (‘client’, ‘driver’, ‘partner’).\nStatus is an ENUM type of (‘Yes’, ‘No’). If the value is ‘Yes’, that means the user is banned.\nWrite a SQL query to find the cancellation rate of requests made by unbanned users (both client and driver must be unbanned) between Oct 1, 2013 and Oct 3, 2013. The cancellation rate is computed by dividing the number of canceled (by client or driver) requests made by unbanned users by the total number of requests made by unbanned users.\nWrite a solution to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) for each day between \"2013-10-01\" and \"2013-10-03\". Round Cancellation Rate to two decimal points.\nReturn the result table in any order.\nThe result format is in the following example.",
    "examples": [
      {
        "input": "Trips table:\n+----+-----------+-----------+---------+---------------------+------------+\n| Id | Client_Id | Driver_Id | City_Id | Status | Request_at |\n+----+-----------+-----------+---------+---------------------+------------+\n| 1 | 1 | 10 | 1 | completed | 2013-10-01 00:00:00 |\n| 2 | 2 | 11 | 1 | cancelled_by_driver | 2013-10-01 00:00:00 |\n| 3 | 3 | 12 | 6 | completed | 2013-10-01 00:00:00 |\n| 4 | 4 | 13 | 6 | cancelled_by_client | 2013-10-01 00:00:00 |\n| 5 | 1 | 10 | 1 | completed | 2013-10-02 00:00:00 |\n| 6 | 2 | 11 | 6 | completed | 2013-10-02 00:00:00 |\n| 7 | 3 | 12 | 6 | completed | 2013-10-02 00:00:00 |\n| 8 | 2 | 12 | 12 | completed | 2013-10-03 00:00:00 |\n| 9 | 3 | 10 | 12 | completed | 2013-10-03 00:00:00 |\n| 10 | 4 | 13 | 12 | cancelled_by_driver | 2013-10-03 00:00:00 |\n+----+-----------+-----------+---------+---------------------+------------+\n\nUsers table:\n+----------+--------+--------+\n| Users_Id | Banned | Role |\n+----------+--------+--------+\n| 1 | No | client |\n| 2 | Yes | client |\n| 3 | No | client |\n| 4 | No | client |\n| 10 | No | driver |\n| 11 | No | driver |\n| 12 | No | driver |\n| 13 | No | driver |\n+----------+--------+--------+\n",
        "output": "+------------+-------------------+\n| Day | Cancellation Rate |\n+------------+-------------------+\n| 2013-10-01 | 0.33 |\n| 2013-10-02 | 0.00 |\n| 2013-10-03 | 0.50 |\n+------------+-------------------+",
        "explanation": "On 2013-10-01:\n  - There were 4 requests in total, 2 of which were canceled.\n  - However, the request with Id=2 was made by a banned client (User_Id=2), so it is ignored in the calculation.\n  - Hence there are 3 unbanned requests in total, 1 of which was canceled.\n  - The Cancellation Rate is (1 / 3) = 0.33\nOn 2013-10-02:\n  - There were 3 requests in total, 0 of which were canceled.\n  - The request with Id=6 was made by a banned client, so it is ignored.\n  - Hence there are 2 unbanned requests in total, 0 of which were canceled.\n  - The Cancellation Rate is (0 / 2) = 0.00\nOn 2013-10-03:\n  - There were 3 requests in total, 1 of which was canceled.\n  - The request with Id=8 was made by a banned client, so it is ignored.\n  - Hence there are 2 unbanned request in total, 1 of which were canceled.\n  - The Cancellation Rate is (1 / 2) = 0.50\nCancellation Rate (2013-10-01) = 1 / 3 = 0.33\nCancellation Rate (2013-10-02) = 0 / 2 = 0.00\nCancellation Rate (2013-10-03) = 1 / 2 = 0.50\nSo the final answer is [0.33, 0.00, 0.50]"
      }
    ],
    "constraints": [
      "Request_at >= \"2013-10-01\" and Request_at <= \"2013-10-03\"",
      "Unbanned users means those users whose Banned value is \"No\".",
      "The percentage must be rounded to 2 decimal places."
    ]
  }
]
